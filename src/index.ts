import { app, BrowserWindow, ipcMain, IpcMainInvokeEvent, session, webContents } from 'electron';
import Parser from 'rss-parser';
import { FeedItem, NewFeedItem } from './types/feed-item';
import { ElectronBlocker } from '@ghostery/adblocker-electron';
import fetch from 'cross-fetch';
import { NewSubscription, Subscription } from './types/subscription';
import Store from 'electron-store';
import db from './database';
import { RefreshFeedResultsMap } from './types/refresh-feed-result';
import { RunResult, Statement } from 'better-sqlite3';
import * as cheerio from "cheerio";
import sharp from 'sharp/lib';

const store = new Store();
const parser : Parser = new Parser();

const faviconBlobRecord : Record<number, Buffer> = {};

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;


// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

app.on('web-contents-created', (event, contents) => {
//   if (contents.getType() === 'webview') {

    contents.setWindowOpenHandler(({ url }) => {
        console.log('Webview requested new window:', url);

        return {
            action: 'allow',
            overrideBrowserWindowOptions: {
                webPreferences: {
                    partition: 'persist:custom-partition',
                    nodeIntegration: false,
                    contextIsolation: true,
                    sandbox: true,
                },
                autoHideMenuBar: true,
            }
        };
    });
//   }
});

const createWindow = () : void => {
    // Create the browser window.
    const mainWindow = new BrowserWindow({
        height        : 600,
        width         : 800,
        webPreferences: {
            preload         : MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
            contextIsolation: true,
            nodeIntegration : false,
            webviewTag      : true,
        },
        autoHideMenuBar: true,
    });

    // and load the index.html of the app.
    mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

    // Open the DevTools.
    mainWindow.webContents.openDevTools();
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.whenReady().then( async () => {
    const blocker = await ElectronBlocker.fromPrebuiltAdsAndTracking(fetch);
    blocker.enableBlockingInSession(session.fromPartition('persist:custom-partition'));

    blocker.on('request-blocked', (req) => {
        console.log('[BLOCKED]', req.url);
    });

    session.defaultSession.webRequest.onHeadersReceived((details, callback) => {
        callback({ cancel: false, responseHeaders: {...details.responseHeaders,
                'Content-Security-Policy': [
                    `
                    default-src 'self';
                    script-src 'self' 'unsafe-eval';
                    style-src 'self' 'unsafe-inline';
                    img-src 'self' blob: data:;
                    font-src 'self' data:;
                    connect-src 'self';
                    object-src 'none';
                    frame-ancestors 'none';
                    base-uri 'self';
                    `
                ],
            }});
    });


    createWindow();

}).catch( (err : Error) =>{
    console.error( "Failed at startup: ", err );
});



// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
if (process.platform !== 'darwin') {
    app.quit();
}
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});




// ------------------------------------------------------------------------------------------------------
function refreshFaviconBlobRecord() {
    console.log('Refreshing favicon blobs');

    const subs = getSubscriptions();
    for( const s of subs ) {
        faviconBlobRecord[s.id] = s.favicon;
    }
}

// ------------------------------------------------------------------------------------------------------
async function urlContainsFeed( url : string ) : Promise<boolean> {
    try {
        const feedRes = await fetch(
            url,
            {
                method: 'GET',
                headers: { 'Accept': 'application/rss+xml, application/atom+xml, application/xml' }
            }
        );

        if( feedRes.ok ) {
            const contentType = feedRes.headers.get("content-type") || "";

            return contentType.includes("application/rss+xml") ||
                    contentType.includes("application/atom+xml") ||
                    contentType.includes("application/xml") ||
                    contentType.includes("text/xml");
        }

    } catch( err ) {
        console.error(err);
    }
    return false;
}

// ------------------------------------------------------------------------------------------------------
ipcMain.handle( 'get-subscriptions', () => {
   return getSubscriptions();
});


// ------------------------------------------------------------------------------------------------------
ipcMain.handle( 'find-feed-url', async ( event: IpcMainInvokeEvent, url : string ) => {
    try {
        if( await urlContainsFeed(url) ) {
            console.log(`Provided URL '${url}' contains a feed`);
            return url;
        }
        console.log(`URL '${url}' does not contain a feed. Will parse document to find links`);

        const res = await fetch(url);
        const html = await res.text();
        const $ = cheerio.load(html);

        let feedURL = null;

        const alternateLinks = $('link[rel="alternate"]');
        if( alternateLinks.length > 0 ) {
            const feedLink = alternateLinks.filter((_, el) => {
                const type = ($(el).attr("type") || "").toLowerCase();
                return type.includes("rss") || type.includes("atom");
            }).first();

            if (feedLink && feedLink.attr("href") ) {
                feedURL = feedLink.attr("href");
            } else {
                console.error('Could not resolve feed href');
            }
        }

        if( !feedURL ) {
            console.warn(`No <link> elements for rss feeds were found. Will scan for other elements that may point to a rss feed (e.g. <a>)`);

            // Fallback
            const aTags = $('a[href]').filter((_, el) => {
                const href = $(el).attr('href') || '';
                return /feed|rss|atom/i.test(href);  // matches /feed.xml, /rss, etc
            });

            if (aTags.length > 0) {
                feedURL = aTags.first().attr("href")!;
            }
        }

        if( feedURL ) {
            const rssURL = new URL(feedURL, url).toString();
            console.log( `Found ${rssURL}` );
            return rssURL;
        }

    } catch (err) {
        console.error("Error fetching or parsing HTML:", err);
    }
    console.warn(`Favicon could not be found for ${url}`);
    return null;
});

// ------------------------------------------------------------------------------------------------------
ipcMain.handle( 'get-feed-favicon', async ( event: IpcMainInvokeEvent, url : string ) : Promise<Buffer | null> => {
    let baseURL = '';
    try {
        baseURL = new URL(url).origin;
    } catch( err ) {
        console.error(err);
        return null;
    }

    try {
        const res = await fetch(baseURL);
        const text = await res.text();
        const $ = cheerio.load(text);

        // Find favicon
        let faviconURL = '';

        const iconLink = $('link[rel="icon"], link[rel="shortcut icon"], link[rel="apple-touch-icon"]').first();
        let iconHref = iconLink.attr("href");

        if( iconHref ) {
            try {
                faviconURL = new URL(iconHref, baseURL).toString();
            } catch( err ) {
                console.warn(`Failed to build URL with ${iconHref}, will attempt /favicon.ico`, err);
            }
        }

        // Fallback
        if( !faviconURL ) {
            faviconURL = new URL( '/favicon.ico', baseURL).toString();
        }

        // Favicon binary data
        const iconRes = await fetch(faviconURL);

        if (iconRes.ok) {
            const buffer = Buffer.from( await iconRes.arrayBuffer() );
            const pngBuffer = await sharp(buffer)
                                        .resize(32, 32, { fit: 'contain' }) // optional resize
                                        .png()
                                        .toBuffer();
            return Buffer.from(pngBuffer);

        } else {
            console.error(iconRes.text);
        }
    } catch( err ) {
        console.warn("Failed to fetch favicon:", err);
    }

    try {
        const googleRes = await fetch(`https://www.google.com/s2/favicons?domain=${baseURL}&size=32`);
        if( googleRes.ok ) {
            return Buffer.from( await googleRes.arrayBuffer() );
        }
    } catch( err ) {
        console.error('Failed to fetch favicon from google', err);
    }

    console.warn('Could not find favicon');
    return null;
});

// ------------------------------------------------------------------------------------------------------
ipcMain.handle( 'get-feed-title', async ( event: IpcMainInvokeEvent, url : string ) => {
    try {
        const res = await fetch(url);
        const txt = await res.text();
        const $ = cheerio.load(txt, { xmlMode: true });

        // RSS
        let title = $('rss > channel > title').first().text();

        // Atom
        if (!title) {
            title = $('feed > title').first().text();
        }
        return title ? title.trim() : url;

    } catch( err ) {
        console.error( err );
        return url;
    }
});

// ------------------------------------------------------------------------------------------------------
ipcMain.handle('refresh-feeds', async ( event: IpcMainInvokeEvent, subs : Subscription[] ) => {
  const results : RefreshFeedResultsMap = {};
  let items : NewFeedItem[] = [];

  for( const s of subs ) {
    try {
      const feed = await parser.parseURL( s.url );

      feed.items.forEach(i => {
        let isRelativeLink = false;
        try {
            new URL(i.link).origin === new URL(s.url).origin;
        } catch( err ) {
            isRelativeLink = true;
        }
        const absoluteURL = (isRelativeLink) ? new URL(i.link, s.url).toString() : i.link;

        const f : NewFeedItem = { 'id':  s.id, 'title': i.title, 'url': absoluteURL, 'pub_date': i.pubDate };
        items.push(f);
      });
      results[s.id] = { success: true, errorMessage: '' };

    } catch( err ) {
      console.error(err);
      results[s.id] = { success: false, errorMessage: err instanceof Error ? err.message : String(err) };
    }
  }

  const stmt: Statement = db.prepare('INSERT INTO feed_item (sub_id, title, url, pub_date) VALUES (?, ?, ?, ?)');
  for( const i of items ) {
    try {
      const res: RunResult = stmt.run( i.id, i.title, i.url, i.pub_date );
      console.log(res);
    } catch( err ) {
      results[i.id] = { success: false, errorMessage: err instanceof Error ? err.message : String(err) };
    }
  }
  return results;
});

// ------------------------------------------------------------------------------------------------------
function getSubscriptions() {
   const stmt = db.prepare('SELECT * FROM subscription');
   return stmt.all() as Subscription[];
}

// ------------------------------------------------------------------------------------------------------
ipcMain.handle( 'get-feeds', ( event: IpcMainInvokeEvent, subs : Subscription[] ) => {
  const stmt = db.prepare('SELECT * FROM feed_item WHERE sub_id = ?');

  let items : FeedItem[] = [];
  for( const s of subs ) {
    items = items.concat( stmt.all(s.id) as FeedItem[] );
  }

  items.sort( (a, b) => {
    const aTime = a.pub_date ? new Date(a.pub_date).getTime() : -Infinity;
    const bTime = b.pub_date ? new Date(b.pub_date).getTime() : -Infinity;
    if( aTime === bTime ) { return 0; }
    return bTime - aTime;
  });
  return items;
});

// ------------------------------------------------------------------------------------------------------
ipcMain.handle( 'add-subscriptions', ( event: IpcMainInvokeEvent, newSubs : NewSubscription[] ) => {
    const stmt = db.prepare( 'INSERT OR IGNORE INTO subscription(name, url, last_updated, favicon) VALUES ( ?, ?, ?, ?)' );
    for( const s of newSubs ) {
        stmt.run( s.name, s.url, s.last_updated, s.favicon );
    }
    refreshFaviconBlobRecord();
});

// ------------------------------------------------------------------------------------------------------
ipcMain.handle( 'get-favicon-data', ( event: IpcMainInvokeEvent, subId : number ) => {
    return faviconBlobRecord[subId];
});