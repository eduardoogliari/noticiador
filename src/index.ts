import { app, BrowserWindow, clipboard, ipcMain, IpcMainInvokeEvent, Menu, MenuItemConstructorOptions, session, shell, webContents } from 'electron';
import Parser from 'rss-parser';
import { FeedItem, NewFeedItem } from './types/feed-item';
import { ElectronBlocker } from '@ghostery/adblocker-electron';
import fetch from 'cross-fetch';
import { NewSubscription, Subscription } from './types/subscription';
import db from './database';
import { RefreshFeedResultsMap } from './types/refresh-feed-result';
import { RunResult, Statement } from 'better-sqlite3';
import * as cheerio from "cheerio";
import sharp from 'sharp/lib';
import { WebContentsView } from 'electron';
import { SubscriptionFilter } from './types/subscription-filter';
import { ModalType } from './types/modal-type';
import { ModalData } from './types/modal-data';
import Store from 'electron-store';
const path = require('path');

type SubscriptionFeedRecord = Record<string, NewFeedItem[]>;

type StoreType = {
    rssCache : SubscriptionFeedRecord;
};
const store = new Store<StoreType>();

const parser : Parser = new Parser({
  customFields: {
    item: ['comments']
  }
});

const faviconBlobRecord : Record<number, Buffer> = {};

const defaultFilterList : string[] = [
    'https://easylist.to/easylist/easylist.txt',
    'https://secure.fanboy.co.nz/fanboy-cookiemonster.txt',
    'https://easylist.to/easylist/easyprivacy.txt',
    'https://secure.fanboy.co.nz/fanboy-annoyance.txt',
    'https://easylist.to/easylist/fanboy-social.txt',
    // 'https://github.com/AdguardTeam/AdguardFilters/blob/master/AnnoyancesFilter/Popups/sections/antiadblock.txt',
];

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const SUBSCRIPTION_ADD_MODAL_WEBPACK_ENTRY: string;
declare const SUBSCRIPTION_DELETE_MODAL_WEBPACK_ENTRY: string;
declare const CONFIRM_EMPTY_BIN_MODAL_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

let wcView : WebContentsView | null = null;
let mainWindow : BrowserWindow | null = null;
let modalWindow : BrowserWindow | null = null;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}


const createWindow = () : void => {
    // Create the browser window.
    mainWindow = new BrowserWindow({
        icon: path.join(__dirname, "../renderer/icons/icon.png"),
        minWidth    : 300,
        minHeight   : 300,
        height      : 600,
        width       : 800,
        webPreferences: {
            preload         : MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
            contextIsolation: true,
            nodeIntegration : false,
        },
        autoHideMenuBar: true,
    });

    // and load the index.html of the app.
    mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);


    const menuTemplate : MenuItemConstructorOptions[] = [
        {
            label: 'File',
            submenu: [
                { role: 'quit' }
            ]
        },
    ];

    const menu = Menu.buildFromTemplate(menuTemplate);
    Menu.setApplicationMenu(menu);



    wcView = new WebContentsView({
        webPreferences: {
            partition: 'persist:custom-partition',
            nodeIntegration: false,
            contextIsolation: true,
            sandbox: true,
            // javascript: false,
        }
    });

    wcView.webContents.setWindowOpenHandler((details) => {
        console.log('Blocked window.open attempt:', details.url);
        return { action: 'deny' };

        // return {
        //     action: 'allow',
        //     overrideBrowserWindowOptions: {
        //         webPreferences: {
        //             partition: 'persist:custom-partition',
        //             nodeIntegration: false,
        //             contextIsolation: true,
        //             sandbox: true,
        //         },
        //         autoHideMenuBar: true,
        //     }
        // };
    });

    wcView.webContents.addListener('did-navigate', (event, url, responseCode, statusText) => {
        mainWindow.webContents.send( 'on-url-changed', url );
    });

    wcView.webContents.addListener('before-mouse-event', (event, mouse) => {
        if( mouse.type == 'mouseDown' ) {
            mainWindow.webContents.send( 'close-popups' );
        }
    });

    mainWindow.contentView.addChildView( wcView );

    // Open the DevTools.
    mainWindow.webContents.openDevTools( {mode:'detach', activate: false, title: 'main'} );
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.whenReady().then( async () => {
    await rebuildAdblock( defaultFilterList );

    session.defaultSession.webRequest.onHeadersReceived((details, callback) => {
        callback({ cancel: false, responseHeaders: {...details.responseHeaders,
                'Content-Security-Policy': [
                    `
                    default-src 'self';
                    script-src 'self' 'unsafe-eval';
                    style-src 'self' 'unsafe-inline';
                    img-src 'self' blob: data:;
                    font-src 'self' data:;
                    connect-src 'self';
                    object-src 'none';
                    frame-ancestors 'none';
                    base-uri 'self';
                    `
                ],
            }});
    });


    createWindow();

}).catch( (err : Error) =>{
    console.error( "Failed at startup: ", err );
});



// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
if (process.platform !== 'darwin') {
    app.quit();
}
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});



ipcMain.on( 'open-modal', ( _, data : ModalData ) => {
    if( modalWindow ) { return; }

    let modalEntryPoint = '';
    let modalWidth      = 0;
    let modalHeight     = 0;
    let modalTitle = '';

    switch( data.type ) {
        case ModalType.AddSubscription:
        {
            modalEntryPoint = SUBSCRIPTION_ADD_MODAL_WEBPACK_ENTRY;
            modalWidth      = 640;
            modalHeight     = 80;
            modalTitle      = data?.data.title ?? 'Add new subscription';
            break;
        }

        case ModalType.ConfirmDeleteSubscription:
        {
            modalEntryPoint = SUBSCRIPTION_DELETE_MODAL_WEBPACK_ENTRY;
            modalWidth      = 500;
            modalHeight     = 90;
            modalTitle      = data?.data.title ?? 'Confirm subscription deletion';
            break;
        }

        case ModalType.ConfirmEmptyBin:
        {
            modalEntryPoint = CONFIRM_EMPTY_BIN_MODAL_WEBPACK_ENTRY;
            modalWidth      = 500;
            modalHeight     = 110;
            modalTitle      = data?.data.title ??'Confirm deletion';
            break;
        }
    }

    modalWindow = new BrowserWindow({
        title: modalTitle,
        parent: mainWindow,
        modal: true,
        show: false,
        width         : modalWidth,
        height        : modalHeight,
        useContentSize: true,
        resizable: false,
        webPreferences: {
            preload         : MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
            contextIsolation: true,
            nodeIntegration : false,
        },
        autoHideMenuBar: true,
    });

    // modalWindow.webContents.openDevTools( {title: 'modal', mode: 'detach', activate: false} );

    modalWindow.loadURL( modalEntryPoint );
    modalWindow.setMenu(null);

    modalWindow.on('closed', () => {
        modalWindow = null;
    });

    modalWindow.webContents.on( 'before-input-event', (event, input) => {
        if (input.type === "keyUp" && input.key === "Escape") {
            closeModalWindow();

        }
    });

    modalWindow.webContents.on( 'did-finish-load', () => {
        modalWindow.webContents.send( 'modal-data', data );
        modalWindow.center();
        modalWindow.show();
    });
});

ipcMain.on( 'close-modal', () => {
    closeModalWindow();
});

function closeModalWindow() {
    if( modalWindow ) {
        modalWindow.close();
    }
}


async function rebuildAdblock( filterLists : string[] ) {
    // const blocker = await ElectronBlocker.fromPrebuiltAdsAndTracking(fetch);
    let blocker = null;

    try {
        blocker = await ElectronBlocker.fromLists( fetch, defaultFilterList );
        console.log( "Created adblocker successfully from lists" );
    } catch( err ) {
        console.error( "Failed to create adblocker from lists: ", err );
    }

    if( !blocker ) {
        try {
            blocker = await ElectronBlocker.fromPrebuiltAdsAndTracking(fetch);
            console.log( "Created default prebuilt adblocker successfully" );
        } catch( err )  {
            console.error( "Failed to create default prebuilt adblocker: ", err );
            return;
        }
    }

    blocker.enableBlockingInSession(session.fromPartition('persist:custom-partition'));

    blocker.on('request-blocked', (req) => {
        console.log('[BLOCKED]', req.url);
    });
}


// ------------------------------------------------------------------------------------------------------
function refreshFaviconBlobRecord() {
    console.log('Refreshing favicon blobs');

    const stmt = db.prepare('SELECT * FROM subscription'); // Intentionally including deleted subs because of favorites
    const subs = stmt.all() as Subscription[];

    for( const s of subs ) {
        faviconBlobRecord[s.id] = s.favicon;
    }
}

// ------------------------------------------------------------------------------------------------------
async function urlContainsFeed( url : string ) : Promise<boolean> {
    try {
        const feedRes = await fetch(
            url,
            {
                method: 'GET',
                headers: { 'Accept': 'application/rss+xml, application/atom+xml, application/xml' }
            }
        );

        if( feedRes.ok ) {
            const contentType = feedRes.headers.get("content-type") || "";

            return contentType.includes("application/rss+xml") ||
                    contentType.includes("application/atom+xml") ||
                    contentType.includes("application/xml") ||
                    contentType.includes("text/xml");
        }

    } catch( err ) {
        console.error(err);
    }
    return false;
}

// ------------------------------------------------------------------------------------------------------
ipcMain.on( "subscriptions-changed", () => {
    mainWindow.webContents.send( 'subscriptions-changed' );
});

// ------------------------------------------------------------------------------------------------------
ipcMain.on( "feed-bin-changed", () => {
    mainWindow.webContents.send( 'feed-bin-changed' );
});

// ------------------------------------------------------------------------------------------------------
ipcMain.handle( 'get-subscriptions', (event: IpcMainInvokeEvent, filter : SubscriptionFilter) => {
    const onlyActiveSubsStmt  = db.prepare('SELECT * FROM subscription WHERE deleted_at IS NULL');
    const onlyDeletedSubsStmt = db.prepare('SELECT * FROM subscription WHERE deleted_at IS NOT NULL');
    const allSubsStmt         = db.prepare('SELECT * FROM subscription');

    switch( filter ) {
        case SubscriptionFilter.ActiveOnly   : return onlyActiveSubsStmt.all() as Subscription[];
        case SubscriptionFilter.DeletedOnly  : return onlyDeletedSubsStmt.all() as Subscription[];
        case SubscriptionFilter.All          : return allSubsStmt.all() as Subscription[];
        default                                 : return allSubsStmt.all() as Subscription[];
    }
});

// ------------------------------------------------------------------------------------------------------
ipcMain.handle( 'find-feed-url', async ( event: IpcMainInvokeEvent, url : string ) => {
    try {
        if( await urlContainsFeed(url) ) {
            console.log(`Provided URL '${url}' contains a feed`);
            return url;
        }
        console.log(`URL '${url}' does not contain a feed. Will parse document to find links`);

        const res = await fetch(url);
        const html = await res.text();
        const redirectedUrl = await res.url;
        const $ = cheerio.load(html);

        let feedURL = $('link[rel="alternate"]')
            .filter((_, el) => {
                const type = ($(el).attr("type") || "").toLowerCase();
                console.log('type ', type);
                return type.includes("rss") || type.includes("atom");
            })
            .attr("href"); // returns from the first match automatically

        if (feedURL) {
            console.log("Feed found:", feedURL);
        } else {
            console.error("Could not resolve feed href");
        }

        if( !feedURL ) {
            console.warn(`No <link> elements for rss feeds were found. Will scan for other elements that may point to a rss feed (e.g. <a>)`);

            // Fallback
            const aTags = $('a[href]').filter((_, el) => {
                const href = $(el).attr('href') || '';
                // return /feed|rss|atom/i.test(href);  // matches /feed.xml, /rss, etc
                return /(?:^|\/)(?:feed(?:\.(?:xml|rss|atom))?|rss(?:\d+)?(?:\.xml)?|atom(?:\.xml)?)(?:\/)?(?=$|[?#])/i.test(href);  // matches /feed.xml, /rss, etc
            });

            if (aTags.length > 0) {
                feedURL = aTags.first().attr("href")!;
            }
        }

        if( feedURL ) {
            // const rssURL = new URL(feedURL, url).toString();
            const rssURL = new URL(feedURL, redirectedUrl).toString();

            if( await urlContainsFeed(rssURL) ) {
                console.log( `Found ${rssURL}` );
                return rssURL;
            }
        }

    } catch (err) {
        console.error("Error fetching or parsing HTML:", err);
    }
    console.warn(`Feed could not be found for ${url}`);
    return null;
});

// ------------------------------------------------------------------------------------------------------
ipcMain.handle( 'get-favicon', async ( event: IpcMainInvokeEvent, url : string ) : Promise<Buffer | null> => {
    let baseURL = '';
    try {
        baseURL = new URL(url).origin;
    } catch( err ) {
        console.error(err);
        return null;
    }

    console.log( 'favicon baseURL: ', baseURL );

    try {
        const res = await fetch(baseURL);
        const text = await res.text();
        const $ = cheerio.load(text);

        console.log( 'favicon redirectedUrl: ', baseURL );

        // Find favicon
        let faviconURL = '';

        const iconLink = $('link[rel="icon"], link[rel="shortcut icon"], link[rel="apple-touch-icon"]').first();
        let iconHref = iconLink.attr("href");

        if( iconHref ) {
            try {
                faviconURL = new URL(iconHref, baseURL).toString();
            } catch( err ) {
                console.warn(`Failed to build URL with ${iconHref}, will attempt /favicon.ico`, err);
            }
        }

        // Fallback
        if( !faviconURL ) {
            console.log( 'favicon URL not found, brute forcing /favicon.ico' );
            faviconURL = new URL( '/favicon.ico', baseURL).toString();
            console.log( 'brute force url: ', faviconURL );
        }

        // Favicon binary data
        const iconRes = await fetch(faviconURL);

        if (iconRes.ok) {
            console.log( 'Building favicon found at ', faviconURL );

            const buffer = Buffer.from( await iconRes.arrayBuffer() );
            const pngBuffer = await sharp(buffer)
                                        .resize(32, 32, { fit: 'contain' }) // optional resize
                                        .png()
                                        .toBuffer();
            return Buffer.from(pngBuffer);

        } else {
            console.error( 'favicon error: ', iconRes.text);
        }
    } catch( err ) {
        console.warn("Failed to fetch favicon:", err);
    }

    try {
        console.log("Will attempt to fetch favicon from google");

        const googleRes = await fetch(`https://www.google.com/s2/favicons?domain=${baseURL}&size=32`);
        if( googleRes.ok ) {
            console.log("Got favicon from google: ", googleRes.url);
            return Buffer.from( await googleRes.arrayBuffer() );
        }
    } catch( err ) {
        console.error('Failed to fetch favicon from google', err);
    }

    console.warn('Could not find favicon');
    return null;
});

// ------------------------------------------------------------------------------------------------------
ipcMain.handle( 'get-feed-title', async ( event: IpcMainInvokeEvent, url : string ) => {
    try {
        const res = await fetch(url);
        const txt = await res.text();
        const $ = cheerio.load(txt, { xmlMode: true });

        // RSS
        let title = $('rss > channel > title').first().text();

        // Atom
        if (!title) {
            title = $('feed > title').first().text();
        }
        return title ? title.trim() : url;

    } catch( err ) {
        console.error( err );
        return url;
    }
});

// ------------------------------------------------------------------------------------------------------
ipcMain.handle('refresh-feeds', async ( event: IpcMainInvokeEvent, subs : Subscription[] ) => {
    const results : RefreshFeedResultsMap = {};
    let newFeedItems : NewFeedItem[] = [];

    let rssCache : SubscriptionFeedRecord = store.get('rssCache');
    if( !rssCache ) {
        rssCache = {};
        store.set('rssCache', rssCache);
    }

    for( const s of subs ) {
        try {
            const feed = await parser.parseURL( s.url );

            if( !rssCache[s.url] ) { rssCache[s.url] = []; }

            let feedItems : NewFeedItem[] =
                feed.items.map( (i) => {
                    let isRelativeLink = false;
                    try {
                        new URL(i.link).origin === new URL(s.url).origin;
                    } catch( err ) {
                        isRelativeLink = true;
                    }
                    const absoluteURL = (isRelativeLink) ? new URL(i.link, s.url).toString() : i.link;

                    return { 'id':  s.id, 'title': i.title, 'url': absoluteURL, 'comments_url': i.comments, 'summary': i.summary,  'pub_date': i.pubDate };
                });

            console.log( `Feed items for ${s.name} in rssCache:  ${rssCache[s.url].length}` );
            newFeedItems.push( ...feedItems.filter( (i) => !rssCache[s.url].find( (f) => f.url === i.url ) ) );

            rssCache[s.url] = feedItems;
            results[s.id] = { success: true, errorMessage: '' };

        } catch( err ) {
            console.error(err);
            results[s.id] = { success: false, errorMessage: err instanceof Error ? err.message : String(err) };
        }
    }

    if( newFeedItems.length > 0 ) {
        console.log( 'newFeedItems: ', newFeedItems );
    } else {
        console.log( 'No new feed items to insert! ---------------------------' );
    }

    const stmt: Statement = db.prepare('INSERT OR IGNORE INTO feed_item (sub_id, title, url, comments_url, summary, pub_date, is_favorite, is_read, in_feed_bin, in_read_later) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)');
    for( const i of newFeedItems ) {
        try {
            const res: RunResult = stmt.run( i.id, i.title, i.url, i.comments_url, i.summary, i.pub_date, 0, 0, 0, 0 );
            console.log(res);
        } catch( err ) {
            results[i.id] = { success: false, errorMessage: err instanceof Error ? err.message : String(err) };
        }
    }

    store.set('rssCache', rssCache);
    return results;
});

// ------------------------------------------------------------------------------------------------------
ipcMain.handle( 'get-feeds', ( event: IpcMainInvokeEvent, subs : Subscription[] ) => {
  const stmt = db.prepare('SELECT * FROM feed_item WHERE sub_id = ? AND in_feed_bin = 0 AND is_favorite = 0');

  let items : FeedItem[] = [];
  for( const s of subs ) {
    items = items.concat( stmt.all(s.id) as FeedItem[] );
  }

  items.sort( (a, b) => {
    const aTime = a.pub_date ? new Date(a.pub_date).getTime() : -Infinity;
    const bTime = b.pub_date ? new Date(b.pub_date).getTime() : -Infinity;
    if( aTime === bTime ) { return 0; }
    return bTime - aTime;
  });
  return items;
});

// ------------------------------------------------------------------------------------------------------
ipcMain.handle( 'add-subscriptions', ( event: IpcMainInvokeEvent, newSubs : NewSubscription[] ) => {
    const existingSubStmt = db.prepare( 'SELECT 1 FROM subscription WHERE url = ? LIMIT 1' );
    const restoreFromSoftDeleteStmt = db.prepare( 'UPDATE subscription SET deleted_at = NULL WHERE url = ?' );

    const stmt = db.prepare( 'INSERT OR IGNORE INTO subscription(name, url, category_id, last_updated, favicon, deleted_at ) VALUES ( ?, ?, ?, ?, ?, ?)' );
    for( const s of newSubs ) {
        const row = existingSubStmt.get( s.url );
        if( row ) {
            // Already exists from a previous soft delete
            console.log( 'Restoring from a soft delete' );
            restoreFromSoftDeleteStmt.run( s.url );
        } else {
            stmt.run( s.name, s.url, s.category_id, s.last_updated, s.favicon, null );
        }
    }
    refreshFaviconBlobRecord();
});

// ------------------------------------------------------------------------------------------------------
ipcMain.handle( 'delete-subscriptions', ( event: IpcMainInvokeEvent, subsToDelete : number[] ) => {
    // If subscription has items favorited, then we soft delete it. Otherwise, we hard delete.

    const softDeleteStmt = db.prepare( 'UPDATE subscription SET deleted_at = CURRENT_TIMESTAMP WHERE id = ?' );
    const hardDeleteStmt = db.prepare( 'DELETE FROM subscription WHERE id = ?' );

    const deleteNonFavoriteItemsStmt = db.prepare( 'DELETE FROM feed_item WHERE sub_id = ? AND is_favorite = 0' );

    const favoriteItemsStmt = db.prepare( 'SELECT 1 FROM feed_item WHERE sub_id = ? AND is_favorite = 1 LIMIT 1' );
    for( const id of subsToDelete ) {
        const row = favoriteItemsStmt.get( id );

        if( row ) {
            // Soft delete
            console.log( 'Soft delete' );
            softDeleteStmt.run( id );
            deleteNonFavoriteItemsStmt.run( id );

        } else {
            // Hard delete
            console.log( 'Hard delete' );
            hardDeleteStmt.run( id );
        }
    }
});

// ------------------------------------------------------------------------------------------------------
ipcMain.handle( 'get-favicon-data', ( event: IpcMainInvokeEvent, subId : number ) => {
    return faviconBlobRecord[subId];
});

// ------------------------------------------------------------------------------------------------------
ipcMain.handle( 'set-favorite', ( event: IpcMainInvokeEvent, itemId : number, value : boolean ) => {

    const stmt = db.prepare( 'UPDATE feed_item SET is_favorite = ? WHERE id = ?' );
    stmt.run( value ? 1 : 0, itemId );
});

// ------------------------------------------------------------------------------------------------------
ipcMain.handle( 'get-favorites', ( event: IpcMainInvokeEvent ) => {
    const stmt = db.prepare( 'SELECT * FROM feed_item WHERE is_favorite = 1 AND in_feed_bin = 0' );
    return stmt.all();
});

// ------------------------------------------------------------------------------------------------------
ipcMain.handle( 'get-feed-bin-items', ( event: IpcMainInvokeEvent ) => {
    const stmt = db.prepare( 'SELECT * FROM feed_item WHERE in_feed_bin = 1 AND is_favorite = 0' );
    return stmt.all();
});

// ------------------------------------------------------------------------------------------------------
ipcMain.handle( 'delete-feed-items', ( event: IpcMainInvokeEvent, itemIds : number[] ) => {
    const stmt = db.prepare( `DELETE FROM feed_item WHERE id IN (${itemIds.map(() => '?').join(',')})` );
    stmt.run( itemIds );
});

// ------------------------------------------------------------------------------------------------------
ipcMain.handle( 'set-read', ( event: IpcMainInvokeEvent, itemId : number, value : boolean ) => {
    const stmt = db.prepare( 'UPDATE feed_item SET is_read = ? WHERE id = ?' );
    stmt.run( value ? 1 : 0, itemId );
});

// ------------------------------------------------------------------------------------------------------
ipcMain.handle( 'set-read-multiple', ( event: IpcMainInvokeEvent, itemIds : number[], value : boolean ) => {
    const stmt = db.prepare( `UPDATE feed_item SET is_read = ? WHERE id IN (${itemIds.map(() => '?').join(',')})` );
    stmt.run( value ? 1 : 0, itemIds );
});

// ------------------------------------------------------------------------------------------------------
ipcMain.handle( 'set-in-feed-bin', ( event: IpcMainInvokeEvent, itemIds : number[], value : boolean ) => {
    const stmt = db.prepare( `UPDATE feed_item SET in_feed_bin = ? WHERE id IN (${itemIds.map(() => '?').join(',')})` );
    stmt.run( value ? 1 : 0, itemIds );
});

// ------------------------------------------------------------------------------------------------------
ipcMain.handle( 'open-external-browser', ( event: IpcMainInvokeEvent, url : string ) => {
    console.log('external: ', url);
    shell.openExternal(url);
});

// ------------------------------------------------------------------------------------------------------
ipcMain.handle( 'copy-to-clipboard', ( event: IpcMainInvokeEvent, text : string ) => {
    clipboard.writeText(text);
});

// ------------------------------------------------------------------------------------------------------
ipcMain.on( 'set-webview-bounds', ( event: IpcMainInvokeEvent, x : number, y : number, width : number, height : number) => {
    wcView?.setBounds( { x: x, y: y, width: width, height: height } );
});

// ------------------------------------------------------------------------------------------------------
ipcMain.on( 'set-webview-url', ( event: IpcMainInvokeEvent, url: string ) => {
    if( wcView?.webContents.getURL() !== url ) {
        wcView?.webContents.loadURL( url );
    }
});

// ------------------------------------------------------------------------------------------------------
ipcMain.handle( 'get-webview-url', ( event: IpcMainInvokeEvent ) => {
    console.log( 'get-webview-url: ', wcView?.webContents.getURL() ?? '' );
    return wcView?.webContents.getURL() ?? '';
});